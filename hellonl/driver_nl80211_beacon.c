#include "common.h"
#include "eloop.h"
#include <net/if.h>
#include <fcntl.h>

#include <netlink/netlink.h>
#include <netlink/genl/genl.h>
#include <netlink/genl/family.h>
#include <netlink/genl/ctrl.h>
#include <netlink/msg.h>
#include <netlink/attr.h>
#include "driver_nl80211.h"
#include "netlink.h"
#include "nl80211.h"

#include "driver_nl80211_frag.h"
#include "ieee802_11_defs.h"

//array of basic rates in 100 kbps (1MB, 2MB, 5.5MB, 11MB)
static int BASIC_RATES[4] = { 10, 20, 55, 110 };
//array of suppported rates in 100 kbps (6MB, 9MB, 12MB, 18MB)
static int SUPPORTED_RATES[4] = { 60, 90, 120, 180 };
//array of suppported rates in 100 kbps (24MB, 36MB, 48MB, 54MB)
static int EXT_RATES[4] = { 240, 360, 480, 540};

inline u8 SUPPORTED_RATE(float rate) { return (u8)((rate)/5); }
inline u8 BASIC_RATE(float rate) { u8 r = SUPPORTED_RATE(rate); r |= 0x80; return r; }


typedef struct {
    u8* d;
    u8 len;
} packet_element_t;

inline u8* packet_element_concatnfree(u8* pos, packet_element_t pkt) {
    memcpy((void*)pos, (void*)pkt.d, pkt.len);
    free(pkt.d);
    pos += pkt.len;
    return pos;
}


static int hostapd_header_beacon(packet_element_t* p, u8* macaddr, u16 beacon_period)
{
    struct ieee80211_mgmt* head=NULL;
    p->len = (u8)(int)&(head->u.beacon.variable[0]);
    head = (struct ieee80211_mgmt*)malloc(p->len);

    // FRAME CONTROL (2) : PROTOCOL=0 + TYPE=MNGT + SUBTYPE=BEACON, FROMDS, TODS....
    head->frame_control = IEEE80211_FC(WLAN_FC_TYPE_MGMT, WLAN_FC_STYPE_BEACON);
    // FRAME DURATION (2) : 0 (typic for broadcast/multicast)
    head->duration = host_to_le16(0);
    // ADDR1 (6) = DA ( destination = broadcast)
    memcpy(head->da, broadcast_ether_addr, ETH_ALEN);
    // ADDR2 (6) = SA ( source = me)
    memcpy(head->sa, macaddr, ETH_ALEN);
    // ADDR3 (6) = BSSID ( me)
    memcpy(head->bssid, macaddr, ETH_ALEN);
    // SEQUENCE-CTRL (2)
    head->seq_ctrl = host_to_le16(0);

    // FRAME BODY FIXED ELEMENTS FOR BEACON
    // BEACON TIMESTAMP (8)
    memset(head->u.beacon.timestamp, 0, sizeof(head->u.beacon.timestamp)); //set by PHY ?
    // BEACON INTERVAL (2)
    head->u.beacon.beacon_int = host_to_le16(beacon_period);
    // BEACON CAPA (2)
    head->u.beacon.capab_info = host_to_le16(0x401); // TODO: check capabilities
    p->d = (u8*)head;
    return p->len;
}

static int hostapd_eid_ssid(packet_element_t* p, const char* ssid) {
    u8 len = strlen(ssid);
    p->len += len + 2;
    p->d = malloc(p->len);
    p->d[0] = WLAN_EID_SSID;
    p->d[1] = len;
    memcpy(&(p->d[2]), ssid, len);
    //fhexdump(stderr, "nl80211: Beacon SSID", p->d, p->len);
    return p->len;
}

static int hostapd_eid_supp_rates(packet_element_t* p) {
    int j,i=2;
    u8 nbBascis = (u8)(sizeof(BASIC_RATES)/sizeof(int));
    u8 nbSuppor = (u8)(sizeof(SUPPORTED_RATES)/sizeof(int));
    u8 len = nbBascis + nbSuppor;
    p->len += len + 2;
    p->d = malloc(p->len);
    p->d[0] = WLAN_EID_SUPP_RATES;
    p->d[1] = len;
    
    for (j = 0; j<nbBascis; j++) p->d[i++] = BASIC_RATE(BASIC_RATES[j]);
    for (j = 0; j<nbSuppor; j++) p->d[i++] = SUPPORTED_RATE(SUPPORTED_RATES[j]);
    //fhexdump(stderr, "nl80211: Beacon rates", p->d, p->len);
    return p->len;
}

static int hostapd_eid_ext_rates(packet_element_t* p) {
    int j,i=2;
    u8 len = (u8)(sizeof(EXT_RATES)/sizeof(int));
    p->len += len + 2;
    p->d = malloc(p->len);
    p->d[0] = WLAN_EID_EXT_SUPP_RATES;
    p->d[1] = len;
    
    for (j = 0; j<len; j++) p->d[i++] = SUPPORTED_RATE(EXT_RATES[j]);
    //fhexdump(stderr, "nl80211: Beacon ext rates", p->d, p->len);
    return p->len;
}

static int hostapd_eid_ds_params(packet_element_t* p) {
    u8 len = 1;
    p->len += len + 2;
    p->d = malloc(p->len);
    p->d[0] = WLAN_EID_DS_PARAMS;
    p->d[1] = len;
    p->d[2] = 6;
    //fhexdump(stderr, "nl80211: Beacon DS-PARAM", p->d, p->len);
    return p->len;
}

static int hostapd_eid_emilie(packet_element_t* p) {
    u8 len = 1;
    p->len += len + 2;
    p->d = malloc(p->len);
    p->d[0] = WLAN_EID_VENDOR_SPECIFIC;
    p->d[1] = len;
    p->d[2] = 0xFF;
    //fhexdump(stderr, "nl80211: Beacon DS-PARAM", p->d, p->len);
    return p->len;
}



/**
     * set_ap - Set Beacon and Probe Response information for AP mode
     *
     * This function is used to configure Beacon template and/or extra IEs
     * to add for Beacon and Probe Response frames for the driver in
     * AP mode. The driver is responsible for building the full Beacon
     * frame by concatenating the head part with TIM IE generated by the
     * driver/firmware and finishing with the tail part.
     * Returns: 0 on success, -1 on failure
     */

int nl80211_set_ap(struct nl80211_data *ctx)
{
    struct nl_msg *msg = NULL;
    int ret;

    u16   beacon_period = 100;
    u8    beacon_DTIM = 1;
    char* ssid_name = "TEST";
    u8    ssid_sz = strlen(ssid_name);

    int j;
    u8 rates[NL80211_MAX_SUPP_RATES];
    u8 nbBascis = (u8)(sizeof(BASIC_RATES)/sizeof(int));
    
    // format basics rates
    for (j = 0; j<nbBascis; j++) rates[j] = BASIC_RATE(BASIC_RATES[j]);

    //portion of the beacon before the TIM IE
    u8 * head = NULL;
    int  head_sz = 0;
    
    //portion of the beacon after the TIM IE
    u8 * tail = NULL;
    int  tail_sz = 0;

    // BEACON HEAD
    {
        u8 * pos = NULL;        
        packet_element_t macheader = { 0 };
        packet_element_t ssid = { 0 };
        packet_element_t rates = { 0 };
        packet_element_t ds = { 0 };

        head_sz += hostapd_header_beacon(&macheader, ctx->macaddr, beacon_period);
        head_sz += hostapd_eid_ssid(&ssid, ssid_name);
        head_sz += hostapd_eid_supp_rates(&rates);
        head_sz += hostapd_eid_ds_params(&ds);

        head = (u8*)malloc(head_sz); pos = head;
        pos = packet_element_concatnfree(pos, macheader);
        pos = packet_element_concatnfree(pos, ssid);
        pos = packet_element_concatnfree(pos, rates);
        pos = packet_element_concatnfree(pos, ds);

        fhexdump(stderr, "nl80211: Beacon head", head, head_sz);
    }

    // BEACON TAIL
    {
        u8 * pos = NULL;
        packet_element_t rates = { 0 };
        //packet_element_t emilie = { 0 };

        tail_sz += hostapd_eid_ext_rates(&rates);
        //tail_sz += hostapd_eid_emilie(&emilie);

        tail = (u8*)malloc(tail_sz); pos = tail;
        pos = packet_element_concatnfree(pos, rates);
        //pos = packet_element_concatnfree(pos, emilie);

        fhexdump(stderr, "nl80211: Beacon tail", tail, tail_sz);
    }

    // NL80211 BEACON SETTING
    msg = nlmsg_alloc();
    if (!msg) goto fail;
    if (!nl80211_cmd(ctx, msg, 0, NL80211_CMD_NEW_BEACON)) goto fail;
    if (nla_put_u32(msg, NL80211_ATTR_IFINDEX, ctx->ifindex)) goto fail;
    
    if (nla_put(msg, NL80211_ATTR_BEACON_HEAD, head_sz, head)) goto fail;
    if (nla_put(msg, NL80211_ATTR_BEACON_TAIL, tail_sz, tail)) goto fail;
    if (nla_put_u32(msg, NL80211_ATTR_BEACON_INTERVAL, beacon_period)) goto fail;
    if (nla_put_u32(msg, NL80211_ATTR_DTIM_PERIOD, beacon_DTIM)) goto fail;    
    if (nla_put(msg, NL80211_ATTR_SSID, ssid_sz, ssid_name)) goto fail;
    
    
    if (nla_put_u32(msg, NL80211_ATTR_HIDDEN_SSID, NL80211_HIDDEN_SSID_NOT_IN_USE)) goto fail;
    if (nla_put_flag(msg, NL80211_ATTR_PRIVACY)) goto fail;
    if (nla_put_u32(msg, NL80211_ATTR_AUTH_TYPE, NL80211_AUTHTYPE_OPEN_SYSTEM)) goto fail;
    if (nla_put_u32(msg, NL80211_ATTR_SMPS_MODE, NL80211_SMPS_OFF)) goto fail;
    ret = send_and_recv_msgs(ctx, msg, NULL, NULL);
    if (ret) {
        fprintf(stderr, "nl80211: Beacon set failed: %d (%s)\n", ret, strerror(-ret));
        goto fail;
    }

    // NL80211 BSS ADVDANCED SETTING
    msg = nlmsg_alloc();
    if (!msg)
        goto fail;
    if (!nl80211_cmd(ctx, msg, 0, NL80211_CMD_SET_BSS))
        goto fail;
    if (nla_put_u32(msg, NL80211_ATTR_IFINDEX, ctx->ifindex))
        goto fail;
    if (nla_put_u8(msg, NL80211_ATTR_BSS_CTS_PROT, 0))
        goto fail;
    if (nla_put_u8(msg, NL80211_ATTR_BSS_SHORT_PREAMBLE, 0))
        goto fail;
    if (nla_put_u8(msg, NL80211_ATTR_BSS_SHORT_SLOT_TIME, 1))
        goto fail;
    if (nla_put_u16(msg, NL80211_ATTR_BSS_HT_OPMODE, 0))
        goto fail;
    if (nla_put_u8(msg, NL80211_ATTR_AP_ISOLATE, 0))
        goto fail;
    if (nla_put(msg, NL80211_ATTR_BSS_BASIC_RATES, nbBascis, rates))
       goto fail;;
    ret = send_and_recv_msgs(ctx, msg, NULL, NULL);
    if (ret) {
        fprintf(stderr, "nl80211: advanced settings failed: %d (%s)\n", ret, strerror(-ret));
        goto fail;
    } 

    if (head) free(head);
    if (tail) free(tail);
    return 0;
fail:
    if (msg) nlmsg_free(msg);
    if (head) free(head);
    if (tail) free(tail);
    return -1;
}

int nl80211_unset_ap(struct nl80211_data *ctx)
{
    struct nl_msg *msg = NULL;
    int ret;
    
    if (!ctx) return -1;
    if (ctx->ifindex<0) return -1;

    msg = nlmsg_alloc();
    if (!msg) goto fail;
    if (!nl80211_cmd(ctx, msg, 0, NL80211_CMD_DEL_BEACON)) goto fail;
    if (nla_put_u32(msg, NL80211_ATTR_IFINDEX, ctx->ifindex)) goto fail;
    ret = send_and_recv_msgs(ctx, msg, NULL, NULL);
    if (ret) {
        fprintf(stderr, "nl80211: advanced settings failed: %d (%s)\n", ret, strerror(-ret));
        goto fail;
    } 
    return 0;
fail:
    if (msg) nlmsg_free(msg);
    return -1;

}